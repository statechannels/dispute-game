# DisputeGame.sol specification

# Purpose

The goal here is to describe DisputeGame in a way that facilitates the security analysis found below. This is important to Optimism; it is also important **for us**, as we plan to write a formal verification of the dispute protocol.

The explicit description also hopefully serves as an implementation guide.

# Context

Suppose Alice & Bob wish to use Layer 1 to dispute some abstract state transition `S -> S'`, but verifying the transition `S -> S'` is very expensive. A DisputeGame enables this by breaking `S->S'` into a sequence of smaller state transitions `S_0 -> S_1`, `S_1 ->S_2`, ..., `S_{n-1} -> S_n`, where

- `S_0 = S`
- `S_n = S'`
- each `S_i -> S_{i+1}` transition is possible to be verified on-chain.

It then "bisects" the sequence of smaller state transitions, coercing Alice or Bob to commit to a transition `S_i -> S_{i+1}` that can be directly invalidated on-chain.

The DisputeGame contract may be used in multiple places of the overall Optimism dispute protocol; therefore, it will be engineered to support at least the following cases:

1. Given an execution trace generated by a single transaction from a starting state root, dispute the validity of the resulting state root by narrowing down to a sequential pair of machine states `M_i, M_{i+1}`, and directly validating or invalidating the `M_i -> M_{i+1}` transition through a `SingleStepVerifier`.
2. Given a state root `R`, a list of transactions `[tx1, tx2, ..., txn]`, and a final state root `R'`, construct an array of state roots `r` where `r[0] = R'`, and `r[k]` is constructed by applying `tx_k` to state root `r[k-1]`. Dispute the transition from `r[0]` to `r[n]` by pointing to a single (allegedly) invalid transition `r[k] -> r[k+1]`, and **_running the dispute game a second time to determine the validity of this transition._**

We can imagine some function `progress` which acts as a "source of truth" that defines a "correct sequence of bytes32 values":

- in case 1, the `SingleStepVerifier` _defines_ a correct sequence of "machine state fingerprints", terminating when the transaction is fully executed.
- in case 2, the correct sequence of state root transitions is _defined by_
  - setting `r[0] = R'`
  - initializing some machine state with state root `r[k-1]`, transaction `tx_k`, and running the `SingleStepVerifier` until a terminal state is reached with state root `r_final`, setting `r[k] = r_final`

The following description is restricted in scope to _correctness_ requirements, and ignores _liveness_ requirements, **assuming that the sequencer & challenger each act in a timely manner.** The specific incentives & timeouts are not considered in this document.

# Dispute game overview

DisputeGame.sol makes the following **assumptions** about "boundary conditions":

1. Alice has a fixed array `a` of bytes32 values.
2. Bob has a fixed array `b` of bytes32 values.
3. `a[0] == b[0]` and `a[m] != b[n]`, where `m = length(a)` and `n = length(b)`
4. `m < n` (if this is not true, switch Alice ←→ Bob)

```tsx
# Alice & Bob's "local views" might be:

a = [0, 1, 2.1, 3, 4, 5.1, 6, 7.1]
b = [0, 1, 2,   3, 4, 5  , 6, 7, 8, 9, 10]

# in this case, m == 8 and n == 11
```

The arrays `a` and `b` may or may not be _correct_, as defined by the relevant "source of truth" `progress` function. (Assumption 4 implies that at most one of `a` and `b` are correct. DisputeGame.sol relies on another component of the rollup to verify assumption 4.)

Alice might "change her mind" during the progress of the game, but this doesn't really matter: we don't care about the values of `a` that are _not_ revealed on-chain, only the values of `a` that _are_ revealed. Once values of `a` are revealed, Alice has committed to them on-chain, and there's no going back.

So, we might as well pretend that `a[i]` is fixed in advanced to be _the value that Alice would reveal if asked to reveal `a[i]`._

The fact that `a[0] == b[0]` is crucial — it implies that Alice and Bob are starting in the same state.

**Game play**

Alice and Bob take turns revealing `a[i]` and `b[i]` for prescribed indices, "bisecting" the two arrays `a` and `b`, continuing until either:

- one party forfeits
- there are two sequential values `x[i], x[i+1]` revealed (`x` is either `a` or `b`) where `x[i] -> x[i+1]` can be invalidated on-chain. We call this outcome "proving fraud".

We outline a DisputeGame.sol specification as well as an off-chain protocol with the following property:

- if Alice is correct, then
  - either Alice moves last and Bob forfeits
  - or Bob moves last, and Alice can prove fraud
- if Bob is correct, then
  - either Bob moves last, and Alice forfeits
  - or Alice moves last, and Bob can prove fraud

## DisputeGame.sol specification

For the rest of this document, division is **_integer division,_** rounded towards 0. (All numbers are positive.)

We assume some unspecified value `k`, the "splitting factor". (This is not specified, because we will need empirical tests to understand eg. the gas cost of various choices of `k`.)

Define `index(i,k,low, high) = low + i * (high - low) / k`

### Initialization

Two values, `numSteps` and `values`, are provided to the constructor.

- `values` is validated to be of length `k+1`
- `numSteps` is validated to be at least `1`.
- A storage variable `mover` is set to be Bob. (Alice is taking the first move during initialization.)
- `values` is recorded in storage.
- A storage value `consensusIndex` is initialized at `0`.
- A storage value `disputedIndex` is initialized at `numSteps`.

**Offchain protocol**: Alice provides "evenly spaced" values of `a` through the `values` variable. Explicitly, she provide `values = a[index(i, k, numSteps) for i = 0,...,k]`.

**Sample behaviour:**

```tsx
Suppose the (local) views are:
a = [0, 1, 2.1, 3, 4, 5.1, 6, 7.1]
b = [0, 1, 2,   3, 4, 5  , 6, 7, 8, 9, 10]

# Initialization; Alice commits to numSteps = 8, reveals a[0], a[3] and a[7]
# This data is now viewable on L1
a = [ 0, _, _, 3, _, _, _, 7.1 ]
b = [ _, _, _, _, _, _, _, _   ]

      lo                   hi

lo = consensusIndex
hi = disputedIndex
values = [0,3,7.1]
mover = Bob
```

### Splitting

Whoever is `mover` is allowed to move. They move by calling a function `split`:

```tsx
split(i: number, newValues: bytes32[], caller)
```

**On-chain behaviour:**

`split` has the following behaviour:

1. It checks that `newValues` is an array of length `k`
2. It checks that `i < k`
3. It checks that `newValues[k-1] != values[i+1]`
4. It checks that `disputedIndex - consensusIndex > k`
5. It checks that `caller` is one of `[Alice, Bob]`, and `caller != mover`
6. It sets `consensusIndex = index(i, k, consensusIndex, disputedIndex)`
7. It sets `disputedIndex = index(i+1, k, consensusIndex, disputedIndex)`
8. It sets `values = [values[i], ...newValues]`
9. It sets `mover = caller`

**Off-chain protocol:** The current mover

- iterates through `i = 0,...,k` to find the last `i` such that `values[i] == x[index(i, k, consensusIndex, disputedIndex)]`, where `x` is their "local view".
- sets `newConsensusIndex = index(i, k, consensusIndex, disputedIndex)`
- sets `newDisputedIndex = index(i+1, k, consensusIndex, disputedIndex)`
- sets `newValues = x[index(j, k, newConsensusIndex, newDisputedIndex) for j = 1,...,k])`
- calls `DisputeGame.split(i, newValues)`

**Sample behaviour:**

```tsx
Suppose the (local) views are:
a = [0, 1, 2.1, 3, 4, 5.1, 6, 7.1]
b = [0, 1, 2,   3, 4, 5  , 6, 7, 8, 9, 10]

# Initialization
a = [ 0, _, _, 3, _, _, _, 7.1 ]
b = [ _, _, _, _, _, _, _, _   ]
      lo                   hi

# Bob agrees with a[3] but disagrees with a[7], and calls split(1, [5,7])
a = [ 0, _, _, 3, _, _, _, 7.1 ]
b = [ _, _, _, 3, _, 5, _, 7   ]
               lo          hi

# now, the values in storage are
consensusIndex = 3
disputedIndex = 7
values = [3,5,7]
mover = Alice

# Alice agrees with b[3] but disagrees with b[5], and calls split(0, [4,5.1])
a = [ 0, _, _, 3, 4, 5.1, _, 7.1 ]
b = [ _, _, _, 3, _, 5,   _, 7   ]
               lo    hi

# now, the values in storage are
consensusIndex = 3
disputedIndex = 7
values = [3,4,5.1]
mover = Bob
```

## Terminating the game

### Detecting fraud

When `disputedIndex - consensusIndex <= k`, no party can call split. Instead, they must finish the game by either "forfeiting" or "pointing fraud".

In this case, Bob knows that `4 -> 5.1` is an incorrect transition

```tsx
a = [ 0, _, _, 3, 4, 5.1, _, 7.1 ]
b = [ _, _, _, 3, _, 5,   _, 7   ]
               lo    hi

consensusIndex = 3
disputedIndex = 7
values = [3,4,5.1]
mover = Bob
```

So, Bob would finish the game by calling `fraudDetected(1)`.

```tsx
fraudDetected(i: number)
```

**On-chain behaviour:**

`fraudDetected(i)` has the following behaviour:

- it validates that `index(i+1, k, consensusIndex, disputedIndex) = index(i, k, consensusIndex, disputedIndex) + 1`
- it sets the game as "terminated" in a "fraud detected" state.

The exact behaviour is unspecified, but an external contract should be able to read:

- who the last `mover` was
- that the game terminated in a "fraud detected" state

**Off-chain protocol:** If a mover knows they can prove fraud about the `values[i] -> values[i+1]` transition for some `i`, they call `fraudDetected(i)`.

### Forfeiting

Suppose the game instead ended up in this state:

```tsx
a = [ _, _, _, 3, _, 5.1, _, 7.1 ]
b = [ 0, _, _, 3, 4, 5,   _, 7   ]
               lo    hi

consensusIndex = 3
disputedIndex = 5
values = [3,4,5]
mover = Alice
```

**On-chain behaviour:**

In this case, Alice is the next mover, but she knows she won't be able to prove fraud. She should be able to finish the game by calling `forfeit`.

```tsx
forfeit();
```

Perhaps Alice should be able to forfeit at any point! Therefore, `forfeit` should have the following behaviour:

- it sets the game as "terminated" in a "fraud detected" state

But, to simplify the security analysis, we assume it has the following behaviour:

- it validates that `disputedIndex == consensusIndex + k`
- it sets the game as "terminated" in a "fraud detected" state

**Off-chain protocol:** If a mover cannot split, and recognizes that they will lose, they call `forfeit`.

# Interface

For now, the interface is defined in Typescript, although the interface will later be converted to Solidity.

```tsx
class ChallengeManager {
  public consensusIndex: number;
  constructor(public values: Bytes32[], public numSplits: number) {}

  split(i: number, values: Bytes32[]): void {}

  fraudDetected(i: number): void;
}
```

# Protocol analysis

## The game maintains a dispute

**Claim:** When the off-chain protocol is followed, the game (almost) maintains the following invariant:

- `a[consensusIndex] == b[consensusIndex] and a[disputedIndex] != b[disputedIndex]`

This invariant is crucial: since they may need to provide some sort of a witness to a `progress` function on layer 1, this

**Proof:**

The game is initialized in a state where `a[consensusIndex] == b[consensusIndex]`.

It's possible that `a[disputedIndex] == b[disputedIndex]` at the start of the game. **Ignore this possibility!**

`forfeit` and `fraudDetected` do not alter storage values other than the "termination status".

`split(i, newValues)` has this effect:

- `consensusIndex` is replaced with `index(i, k, consensusIndex, disputedIndex)`, the same value as the (local) variable `newConsensusIndex`
- `disputedIndex` is replaced with `index(i+1, k, consensusIndex, disputedIndex)`, the same value as the (local) variable `disputedIndex`
- `values[0]` is replaced with `oldValues[newConsensusIndex]`
- `values[k]` is replaced with `oldValues[newDisputedIndex]`

TODO: Finish this proof.

## The game terminates quickly

**Claim:** The game terminates in `log_k(m)` rounds.

**Rough proof:**

For any `i < k` and `y > x + k`, \*\*\*\*`index(i+1, k, x, y) - index(i, k, x, y) <= (y - x) / k` (or something like that)

## When terminated, the dispute is correctly resolved

**Claim:**

- If Alice was correct
  - if Bob was the last mover, then Alice has proven fraud
  - if Alice was the last mover, then Bob cannot prove fraud
- If Bob was correct
  - if Alice was the last mover, then Bob has proven fraud
  - if Bob was the last mover, then Alice cannot prove fraud

**Proof:**

TODO

# Optimizations

## Storage

Since storage is expensive, DisputeGame.sol should not store `values`. Instead, the contract should store a _commitment_ to `values`, such that the next mover can prove to the contract:

- `values[i] = v_0`
- `values[i+1] = v_1`

One option is for the contract to construct a merkle tree whose leaves have values taken from `values`, and storing the root of this tree.

The interface would then look like the following:

```tsx
interface Witness {
  value: Bytes32;
  index: number;
  siblingHashes: Bytes32[];
}

class DisputeGame {
  private merkleRoot: Bytes32;
  public consensusIndex = 0;
  constructor(public values: Bytes32[], public numSplits: number) {}

  split(consensusWitness: Witness, values: Bytes32[], disputedWitness: Witness, caller): void {}

  fraudDetected(consensusWitness: Witness, disputedWitness: Witness): void {}

  forfeit();
}
```

`split` and `fraudDetected` should validate each `Witness` against the stored `merkleRoot`, which serves as a proof that `values[witness.index] == witness.value`.
